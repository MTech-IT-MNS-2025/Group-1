# Compile C code to WebAssembly and execute in browser using JavaScript

---

- Platform used: `Fedora`
- Technologies used: `Emscripten`, `NodeJs`, `Next.js`, `JavaScript`

---

## Installation

### Install git

# On Fedora

```shell
sudo dnf install git
```

### Install emsdk

```shell
# Get the emsdk repo
git clone https://github.com/emscripten-core/emsdk.git

cd emsdk

# Download and install the latest SDK tools.
./emsdk install latest

# Fetch the latest registry of available tools.
./emsdk update

# Make the "latest" SDK "active" for the current user. (writes .emscripten file)
./emsdk activate latest

# Activate PATH and other environment variables in the current terminal
source ./emsdk_env.sh
```

If you want to avoid executing source ./emsdk_env.sh every time you open a new terminal, you can follow the instructions given by the emsdk activate command above to add this command to your startup scripts.

Emscripten, like gcc and clang, generates unoptimized code by default. Code is optimized by specifying optimization flags when running emcc. The levels include: `-O0` (no optimization), `-O1`, `-O2`, `-Os`, `-Oz`, `-Og`, and `-O3`.


### Making myProg.js and myProg.wasm

```shell
emcc myProg.c -o myProg.js -Oz --closure 1 -sEXPORTED_FUNCTIONS=_modexp -sEXPORTED_RUNTIME_METHODS=cwrap
```

You should see two files generated by that command: myProg.js and myProg.wasm. The second is a WebAssembly file containing the compiled code, and the first is a JavaScript file containing the runtime support to load and execute it.

### Install Node.js and npm

# On Fedora

```shell
sudo dnf install nodejs npm
```


### Running the app

In Lab_Test folder,

```shell
npm install
npm run dev
```

Open frontend in browser


## Architecture

```shell
Lab_Test
│
├───app
│       page.js
│		api
│			run-server
│				route.js
│
├───public
        myProg.c
        myProg.js
        myProg.wasm
```

## Technologies Used
- **C**: Implements the core Diffie-Hellman algorithm.
- **Emscripten**: Compiles C code into WebAssembly.
- **WebAssembly (WASM)**: Runs C code efficiently in browser.
- **Next.js**: Provides the React-based web interface.
- **JavaScript / React**: Connects UI to WASM functions.

## Learning Outcomes
1. How to compile C code to WebAssembly using Emscripten.
2. How to expose C functions to JavaScript.
3. How to call native C (via WASM) from a Next.js frontend.
4. How to handle text input/output between JavaScript and WASM memory.

## Hash

Calculated using `md5sum`
